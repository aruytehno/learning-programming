'''
Функциональное программирование
Функциональное программирование – это стиль программирования, который (как предполагает имя) основан на функциях.
Ключевой частью функционального программирования являются функции высшего порядка. Функции высшего порядка принимают
функции в качестве аргументов или возвращают их как результат.
'''

def example_1(func, arg):
  return func(func(arg))

def mult_example_1(x):
  return x * x
def test_func():
    print(example_1(mult_example_1, 2))


'''
Чистые функции
Функциональное программирование стремится к использованию чистых функций. Чистые функции не имеют побочных эффектов и возвращают значение, которое зависит только от своих аргументов.
Вот как работают функции в математике: например, cos(x) для одного и того же значения x всегда будет возвращать один и тот же результат.
Ниже приведены примеры чистых и нечистых функций.

Использование чистых функций имеет свои преимущества и недостатки.
Чистые функции:
- проще понимать и тестировать.
- более эффективные. После того как функция обработала входные данные, результат можно сохранить и использовать в следующий раз, когда он потребуется, что снижает количество вызовов функции. Это называется мемоизацией.
- легче запускать параллельно.

Чистые функции сложнее писать в некоторых случаях.
'''

# Чистая функция:
def pure_function(x, y):
  temp = x + 2*y
  return temp / (2*x + y)

# Нечистая функция:
some_list = []

def impure(arg):
  some_list.append(arg)



'''
Лямбда-Функции
Обычное создание функции (с помощью def) автоматически присваивает ее переменной с ее именем.
Python позволяет нам создавать функции на лету, при условии, что они созданы с использованием лямбда-синтаксиса.

Этот подход чаще всего используется при передаче простой функции в качестве аргумента другой функции. 
Это синтаксис показан в следующем примере и включает ключевое слово lambda, за которым следует список аргументов, 
двоеточие и выражение для оценки и возврата.

Функции, созданные с помощью лямбда-синтаксиса называются анонимными.
'''

def my_func(f, arg):
  return f(arg)

def test_my_func():
    print(my_func(lambda x: 2*x*x, 5))

def test_lambda_function():
    print((lambda x: x**2)(3))


'''
map
Встроенные функции map и filter являются очень полезными функциями высшего порядка, которые работают со списками 
(или подобными итерируемыми объектами).
Функция map принимает функцию и итерируемый объект в качестве аргументов и возвращает новый итерируемый объект с 
функцией, примененной к каждому аргументу.
'''

'''
filter
Функция filter фильтрует итерируемый объект, оставляя только те элементы, которые соответствуют условию 
(также известному как предикат).
'''

def test_filter():
    # nums = [1, 2, 5, 8, 3, 0, 7]
    nums = [1, 2, 8, 3, 7]
    print(list(filter(lambda x: x % 2 == 0, nums)))


'''
Генераторы
Генераторы являются типом итерируемого объекта, как списки или кортежи.
В отличие от списков, они не допускают индексирование произвольными индексами, но их все еще можно итерировать с помощью цикла for.
Их можно создавать с помощью функций и оператора yield.
'''


def infinite_sevens():
    i = 5
    while i < 10:
        yield i
        i += 1

def test_yield():
    for i in infinite_sevens():
        print(i)

def make_word():
    word = ""
    for ch in "spam":
        word += ch
        yield word

def test_make_word():
    print(list(make_word()))


"""
Декораторы
Декораторы предоставляют способ модификации функций с помощью других функций.
Это идеально подходит, когда вам нужно расширить функциональность функций, 
которые вы не хотите изменять.

Python обеспечивает поддержку обертывания функции в декораторе, предварительно добавляя 
определение функции с именем декоратора и символом @.
Если мы определяем функцию, мы можем «декорировать» ее с помощью символа @:
"""

'''
Рекурсия
Рекурсия является очень важной концепцией в функциональном программировании.

Фундаментальной частью рекурсии является обращение к самой себе – функции вызывают себя сами. Это используется для 
решения проблем, которые могут быть разбиты на более легкие подпроблемы того же типа.

Классическим примером рекурсивной функции является факториальная функция, которая находит произведение всех 
положительных чисел до указанного числа.
Например, 5! (факториал 5) является 5 * 4 * 3 * 2 * 1 (120). Чтобы реализовать это рекурсивно, обратите внимание, 
что 5! = 5 * 4!, 4! = 4 * 3!, 3! = 3 * 2! и так далее. В целом, n! = n * (n-1)!.
Кроме того, 1! = 1. Это называется базовым случаем, поскольку его можно вычислить без дополнительных факториалов.
Ниже представлена рекурсивная реализация факториальной функции.

Базовый случай действует как условие выхода из рекурсии.
Отсутствие базового случая приводит к бесконечным вызовам функции и сбою программы.

Рекурсия
Рекурсия также может быть косвенной. Одна функция может вызывать другую, которая вызывает первую, которая вызывает
вторую, и так далее. Это может происходить с любым количеством функций.

def fib(x):
  if x == 0 or x == 1:
    return 1
  else:
    return fib(x-1) + fib(x-2)
print(fib(4))
'''


'''
*args
Python допускает функции с непостоянным количеством аргументов.
Использование *args в качестве параметра функции позволяет передать произвольное количество аргументов этой функции. 
Эти аргументы становятся доступными в качестве кортежа args в теле функции.

Параметр *args должен идти после именных параметров функции.
Имя args является просто соглашением, вы можете выбрать другое.
'''

'''
**kwargs
**kwargs (что означает аргумент ключевого слова) позволяет обрабатывать именованные аргументы, которые не были 
определены заранее.
Аргументы ключевого слова возвращают словарь, в котором ключами являются имена аргументов, а значениями – значения 
аргументов.

Аргументы, которые возвращает **kwargs не включены в *args.
'''