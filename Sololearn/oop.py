'''
Классы
Центральное место в Объектно-Ориентированном Программировании (ООП) занимают объекты, которые создаются с
помощью классов.
Класс описывает, каким будет объект, но является отдельным от самого объекта. Другими словами, класс может быть описан
как шаблон объекта, описание или определение.
Вы можете использовать один класс в качестве шаблона для создания множества различных объектов.

Классы создаются с помощью ключевого слова class и блока с отступом, который содержит методы класса
(которые являются функциями).
Ниже представлен пример простого класса и его объектов.

__init__
Метод __init__ является самым важным методом в классе.
Он вызывается при создании экземпляра (объекта) класса, используя имя класса в качестве функции.

Все методы должны иметь self в качестве первого параметра, хотя он явно не передается, Python добавляет аргумент self в
 список за вас, вам не нужно включать его при вызове методов. Внутри определения метода, self относится к экземпляру,
 вызывающему метод.

Экземпляры класса имеют атрибуты, которые являются фрагментами данных, связанными с ними.
В этом примере, экземпляры Cat имеют атрибуты color и legs. К ним можно получить доступ, поставив точку и имя атрибута
после экземпляра.
В методе __init__, self. attribute может использоваться для установки начального значения атрибутов экземпляра.

Методы
У классов могут быть другие методы, определенные, чтобы добавить классам функциональности.
Помните, что все методы должны иметь self в качестве первого параметра.
Доступ к этим методам осуществляется с помощью того же точечного синтаксиса, как и для атрибутов.

Атрибуты класса передаются всем экземплярам класса.

Наследование
Наследование предоставляет способ передачи функциональности между классами. Давайте представим несколько классов, Cat,
Dog, Rabbit и так далее. Хотя они могут чем-то отличаться (только Dog может иметь метод bark), они, скорее всего, будут
 похожи в другом (у всех есть атрибуты color и name).
Это сходство может быть выражено, если все они унаследованы от суперкласса Animal, который содержит общую
функциональность.
Чтобы унаследовать класс из другого класса, поместите имя суперкласса в круглые скобки после имени класса.

Класс, который наследуется из другого класса, называется подклассом.
Класс, из которого осуществляется наследование, называется суперклассом.
Если класс наследуется из другого класса с теми же атрибутами и методами, то он их переопределяет.

Функция super – это полезная функция, связанная с наследованием, которая относится к родительскому классу. Ее можно
использовать для нахождения метода с определенным именем в суперклассе объекта.



Магические методы
Магические методы являются специальными методами, которые имеют двойное подчеркивание в начале и в конце своего имени.
Они также называются дандерами.
На данный момент, нам знаком только __init__, но есть еще несколько других.
Их используют для создания функциональности, которая не может быть представлена в качестве обычного метода.

Одно из их распространенных применений – перегрузка операторов.
Это означает определение операторов для пользовательских классов, которые позволяют использовать с ними такие операторы, как + и *.
Примером магического метода является __add__ для +.


Метод __add__ позволяет определять настраиваемое поведение для оператора + в нашем классе.
Как вы можете видеть, он добавляет соответствующие атрибуты объектов и возвращает новый объект, содержащий результат.
После определения, мы можем сложить два объекта класса.

Магические методы
Магические методы являются специальными методами, которые имеют двойное подчеркивание в начале и в конце своего имени.
Они также называются дандерами.
На данный момент, нам знаком только __init__, но есть еще несколько других.
Их используют для создания функциональности, которая не может быть представлена в качестве обычного метода.

Одно из их распространенных применений – перегрузка операторов.
Это означает определение операторов для пользовательских классов, которые позволяют использовать с ними такие операторы, как + и *.
Примером магического метода является __add__ для +.

Магические методы
Еще магические методы для распространенных операторов:
__sub__ for -
__mul__ for *
__truediv__ for /
__floordiv__ for //
__mod__ for %
__pow__ for **
__and__ for &
__xor__ for ^
__or__ for |

Выражение x + y преобразовано в x.__add__(y).
Однако если в x не реализован __add__, и x и y являются различными типами, тогда вызывается y.__radd__(x).
Существуют эквивалентные методы r для всех только что упомянутых магических методов.


Python также предоставляет магические методы для сравнения.
__lt__ для <
__le__ для <=
__eq__ для ==
__ne__ для!=
__gt__ для >
__ge__ для >=

Если __ne__ не реализован, он возвращает обратное от __eq__.
Других отношений между другими операторами нет.


Есть несколько магических методов, которые заставляют классы вести себя как контейнеры.
__len__ для len()
__getitem__ для индексирования
__setitem__ для присваивания индексированных значений
__delitem__ для удаления индексированных значений
__iter__ для итерации по объектам (например, в циклах for)
__contains__ для in

Есть множество магических методов, которые мы не будем здесь рассматривать, например, __call__ для вызова объектов в
качестве функций и __int__, __str__,и подобные для преобразования объектов во встроенные типы.


Скрытие данных
Ключевой частью объектно-ориентированного программирования является инкапсуляция, которая подразумевает упаковку связанных переменных и функций в один простой в использовании объект – экземпляр класса.
Связанное с этим понятие – скрытие данных, в котором говорится, что детали реализации класса должны быть скрыты, и чистый стандартный интерфейс представлен для тех, кто хочет использовать класс.
В других языках программирования, это обычно осуществляется с помощью приватных методов и атрибутов, которые блокируют внешний доступ к определенным методам и атрибутам класса.

У Python немного другая философия. Часто говорится, что «мы все здесь взрослые по согласию», что означает, что вы не должны вводить произвольные ограничения на доступ к частям класса. Следовательно, нет способов принудительно сделать метод или атрибут строго приватным.


Однако есть способы отговорить людей от доступа к частям класса, например, указав, что это деталь реализации и что они должны использоваться на свой страх и риск.

Слабо приватные методы имеют одинарное нижнее подчеркивание в начале.
Это сигнализирует о том, что они частные и не должны использоваться внешним кодом. Однако это в основном всего лишь соглашение и не мешает внешнему коду получить к ним доступ.

Строго приватные методы и атрибуты имеют двойное нижнее подчеркивание в начале своего имени. Это приводит к искажению их имен, что означает, что к ним нельзя получить доступ извне класса.
Цель этого не в том, чтобы гарантировать их конфиденциальность, а во избежание ошибок, если существуют подклассы, у которых есть методы или атрибуты с одинаковыми именами.
Методы с измененным именем все еще доступны извне, но под другим именем. Метод __privatemethod класса Spam доступен извне с помощью _Spam__privatemethod.

Методы класса
Методы объектов, которые мы рассмотрели на данный момент, вызываются экземпляром класса, который затем передается в параметр self метода.
Методы класса отличаются – они вызываются классом, который передается в параметр cls метода.
Обычно используются фабричные методы, которые создают экземпляр класса, используя параметры, отличные от тех, которые обычно передаются конструктору класса.
Методы класса помечаются декоратором classmethod.


Статические методы подобны методам класса, за исключением того, что они не получают дополнительных аргументов; они идентичны обычным функциям, принадлежащим классу.
Они помечаются декоратором staticmethod.

Свойства
Свойства предоставляют способ настройки доступа к атрибутам экземпляра.
Они создаются путем помещения декоратора property над методом, что означает, что при обращении к атрибуту экземпляра с тем же именем, что и у метода, вместо него будет вызываться метод.
Один из распространенных способов использования свойства - сделать атрибут доступным только для чтения.


Свойства также могут быть установлены путем определения функций setter/getter.
Функция setter устанавливает значение соответствующего свойства.
Getter получает значение.
Чтобы определить сеттер, вам нужно использовать декоратор с тем же именем, что и у свойства, за которым следует точка и ключевое слово setter.
То же самое относится к определению функции getter.
'''


'''
Исключения
Вы уже видели исключения в предыдущем коде. Они возникают, когда что-то идет не так из-за недействительного кода или
 ввода. Когда возникает исключение, программа немедленно останавливается.


Различные исключения возникают по различным причинам.
Распространенные исключения:
ImportError: ошибка импорта;
IndexError: список проиндексирован с номером вне допустимого диапазона;
NameError: используется неизвестная переменная;
SyntaxError: код не может быть проанализирован должным образом;
TypeError: функция вызывается для значения несоответствующего типа;
ValueError: функция вызывается для значения правильного типа, но с несоответствующим значением

Python имеет еще несколько встроенных исключений, например, ZeroDivisionError и OSError. 
Сторонние библиотеки также часто определяют свои собственные исключения.

Обработка исключений
При возникновении исключения программа перестает выполняться.
Для обработки исключений и вызова кода при возникновении исключения вы можете использовать конструкцию try/except.
Блок try содержит код, который может вызвать исключение. Если исключение возникнет, код в блоке try перестанет
выполняться, и выполнится код в блоке except. Если ошибка не возникнет, код в блоке except не выполнится.

Поскольку код создает исключение ZeroDivisionError, код в блоке except выполнится.

Конструкция try может иметь множество различных блоков except для обработки различных исключений.
Множественные исключения также могут быть помещены в один блок except с помощью круглых скобок, чтобы блок except 
обработал их всех.

Конструкция except без указанного исключения будет перехватывать все ошибки. Это следует использовать с осторожностью, 
поскольку это может выявить неожиданные ошибки и скрыть ошибки в коде.


После конструкции try/catch может следовать блок finally. Он выполнится после блока try/catch, независимо от того, 
возникло исключение или нет.

Блок finally полезен, например, при работе с файлами и ресурсами: его можно использовать, чтобы убедиться, что файлы
или ресурсы будут закрыты или освобождены независимо от того, возникнет ли исключение.

try:
    print(1)
except:
    print(2)
finally:
    print(3)


Конструкция else также может использоваться с конструкцией try/except.
В этом случае, код внутри нее выполнится только, если не возникнет ошибки в конструкции try.

Вы можете вызывать (или поднимать) исключения, когда возникнет определенное условие.
Например, когда вы принимаете пользовательский ввод, который должен быть в определенном формате, вы можете вызвать
исключение, если он не соответствует требованиям.
Это осуществляется с помощью оператора raise.

сключения могут быть вызваны с аргументами, которые их описывают.
'''
